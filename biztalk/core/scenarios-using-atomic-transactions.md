---
title: Escenarios de uso de transacciones atómicas | Documentos de Microsoft
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- Scope shape [Orchestration Designer], examples
- Scope shape [Orchestration Designer], atomic transactions
- transactions, examples
- transactions, atomic
- atomic transactions, examples
- examples, atomic transactions
ms.assetid: f3481b4e-7e7e-47f0-b8f4-6012a2fc5310
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e73cfea7a99e2fafbf115a367dbf0840de3369c3
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 09/20/2017
ms.locfileid: "22270948"
---
# <a name="scenarios-using-atomic-transactions"></a><span data-ttu-id="25016-102">Escenarios que usan transacciones atómicas</span><span class="sxs-lookup"><span data-stu-id="25016-102">Scenarios Using Atomic Transactions</span></span>
<span data-ttu-id="25016-103">En los escenarios siguientes se describe el uso de transacciones atómicas.</span><span class="sxs-lookup"><span data-stu-id="25016-103">The following scenarios describe the use of atomic transactions.</span></span>  
  
## <a name="scenario-1-an-atomic-transaction-with-com-servicedcomponent"></a><span data-ttu-id="25016-104">Escenario 1: Una transacción atómica con ServicedComponent de COM +</span><span class="sxs-lookup"><span data-stu-id="25016-104">Scenario 1: An Atomic Transaction with COM+ ServicedComponent</span></span>  
 <span data-ttu-id="25016-105">La siguiente orquestación muestra cómo utilizar el **RetryTransactionException** con transacciones atómicas.</span><span class="sxs-lookup"><span data-stu-id="25016-105">The following orchestration shows how to use the **RetryTransactionException** with atomic transactions.</span></span> <span data-ttu-id="25016-106">Aunque los controladores de excepción se pueden incluir directamente para un ámbito atómico, el ámbito puede incluir un ámbito no transaccional que puede tener un controlador de excepción.</span><span class="sxs-lookup"><span data-stu-id="25016-106">Although exception handlers cannot be directly included for an atomic scope, the scope can include a non-transactional scope that can have an exception handler.</span></span> <span data-ttu-id="25016-107">El **ServicedComponent** da de alta en la misma transacción DTC y cualquier excepción producida por el componente es detectada y reenviada como **RetryTransactionException**.</span><span class="sxs-lookup"><span data-stu-id="25016-107">The **ServicedComponent** enlists in the same DTC transaction and any exception raised by the component is caught and re-thrown as **RetryTransactionException**.</span></span> <span data-ttu-id="25016-108">(Se supone que la **vuelva a intentar** propiedad está establecida en **True** para el ámbito atómico).</span><span class="sxs-lookup"><span data-stu-id="25016-108">(This assumes that the **Retry** property is set to **True** for the atomic scope).</span></span>  
  
 <span data-ttu-id="25016-109">Tenga en cuenta que la orquestación se habría suspendida y se habría revierte la acción en la forma asignación de mensajes incluso si la **RetryTransactionException** no se produce.</span><span class="sxs-lookup"><span data-stu-id="25016-109">Note that the orchestration would have been suspended and the action in the MessageAssignment shape would have been rolled back even if the **RetryTransactionException** is not thrown.</span></span> <span data-ttu-id="25016-110">No obstante, este patrón permite aportar estabilidad a la aplicación donde se producen reintentos automáticamente.</span><span class="sxs-lookup"><span data-stu-id="25016-110">This pattern, however, allows building resilience in the application where the retries occur automatically.</span></span>  
  
 <span data-ttu-id="25016-111">**Una transacción atómica con ServicedComponent de COM +**</span><span class="sxs-lookup"><span data-stu-id="25016-111">**An atomic transaction with COM+ ServicedComponent**</span></span>  
  
 <span data-ttu-id="25016-112">![Una transacción atómica con COM &#43; ServicedComponent](../core/media/bts-trans-orch-fig5.gif "BTS_Trans_Orch_Fig5")</span><span class="sxs-lookup"><span data-stu-id="25016-112">![An atomic transaction with COM&#43; ServicedComponent](../core/media/bts-trans-orch-fig5.gif "BTS_Trans_Orch_Fig5")</span></span>  
  
## <a name="scenario-2-using-transacted-adapters-with-atomic-transactions"></a><span data-ttu-id="25016-113">Escenario 2: Usar adaptadores de transacción con transacciones atómicas</span><span class="sxs-lookup"><span data-stu-id="25016-113">Scenario 2: Using Transacted Adapters with Atomic Transactions</span></span>  
 <span data-ttu-id="25016-114">La siguiente orquestación muestra cómo usar transacciones atómicas con el adaptador de SQL.</span><span class="sxs-lookup"><span data-stu-id="25016-114">The following orchestration shows how to use the atomic transactions with the SQL adapter.</span></span> <span data-ttu-id="25016-115">Toda la orquestación está marcada como de larga ejecución con transacciones atómicas individuales para los dos elementos de trabajo lógicos: insertar un nuevo cliente y un orden de inserción de detalles para el cliente.</span><span class="sxs-lookup"><span data-stu-id="25016-115">The whole orchestration is marked as long running with individual atomic transactions for the two logical pieces of work: Inserting a new Customer and Insert Order details for the customer.</span></span>  
  
 <span data-ttu-id="25016-116">Si, por cualquier motivo, se produce un error en la inserción del pedido, debería deshacer la inserción del cliente.</span><span class="sxs-lookup"><span data-stu-id="25016-116">If, for whatever reason, the Order Insert fails, the Customer Insert should be rolled back.</span></span> <span data-ttu-id="25016-117">En el ejemplo se usa el adaptador de SQL para hacer el trabajo de base de datos.</span><span class="sxs-lookup"><span data-stu-id="25016-117">The sample uses the SQL adapter to do the database work.</span></span> <span data-ttu-id="25016-118">Tal y como se mencionó anteriormente, el ámbito asociado con una transacción atómica se completa cuando se envía el mensaje a la base de datos de cuadro de mensajes.</span><span class="sxs-lookup"><span data-stu-id="25016-118">As mentioned earlier, the scope associated with an atomic transaction completes when the message is sent to the MessageBox database.</span></span> <span data-ttu-id="25016-119">Esto implica que, una vez que el motor ha enviado correctamente el mensaje en los ámbitos Scope_InsertCustomer y Scope_InsertOrder, se confirma cada uno de los ámbitos.</span><span class="sxs-lookup"><span data-stu-id="25016-119">This implies that after the engine is successful in sending the message in the Scope_InsertCustomer and Scope_InsertOrder scopes, each one of the scopes commits.</span></span> <span data-ttu-id="25016-120">El adaptador de SQL crea una nueva transacción para la inserción real del cliente o el orden.</span><span class="sxs-lookup"><span data-stu-id="25016-120">The SQL adapter creates a new transaction for the actual Insert of the Customer or the order.</span></span>  
  
 <span data-ttu-id="25016-121">Los puertos tienen una propiedad “Notificación de entrega” para validar que el mensaje se ha enviado correctamente a través del puerto de envío.</span><span class="sxs-lookup"><span data-stu-id="25016-121">The Ports have a property “Delivery Notification” for validating that the message has been successfully sent via the Sent Port.</span></span> <span data-ttu-id="25016-122">Si la propiedad Notificación de entrega está establecida en “Transmitted”, se coloca una suscripción de recepción antes del punto de confirmación transaccional de la operación de envío.</span><span class="sxs-lookup"><span data-stu-id="25016-122">When the Delivery Notification property is set to “Transmitted”, a receive subscription is placed before the Transactional commit point of the Send Operation.</span></span> <span data-ttu-id="25016-123">No obstante, en el caso de ámbitos atómicos, la suscripción de recepción se coloca en el ámbito primario envolvente.</span><span class="sxs-lookup"><span data-stu-id="25016-123">However, in case of Atomic Scopes, the receive subscription is placed in the enclosing Parent scope.</span></span>  
  
 <span data-ttu-id="25016-124">En el escenario donde la transacción SQL InsertOrder produce un error, se devolverá un mensaje de confirmación negativa y se confirma “Scope_InsertOrder”.</span><span class="sxs-lookup"><span data-stu-id="25016-124">In the scenario where the InsertOrder SQL transaction fails, a "Nack" will be sent back and the "Scope_InsertOrder" commits.</span></span> <span data-ttu-id="25016-125">Una vez que el puerto de envío agota los reintentos configurados, se genera una excepción DeliveryFailureException.</span><span class="sxs-lookup"><span data-stu-id="25016-125">After the Sent Port exhausts the configured retries, a DeliveryFailureException will be raised.</span></span> <span data-ttu-id="25016-126">El controlador de excepción predeterminado detectará esta excepción, que ejecutará el proceso de compensación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="25016-126">This exception will be caught by the default exception handler, which will run the default compensation process.</span></span> <span data-ttu-id="25016-127">Esto invocará a los controladores de compensación asociados a Scope_InsertCustomer y Scope_InsertOrder, lo que provocará la operación deshacer para la inserción de la información de cliente.</span><span class="sxs-lookup"><span data-stu-id="25016-127">This will invoke the compensation handlers associated with the Scope_InsertCustomer and Scope_InsertOrder, causing the undo operation of inserting the customer information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="25016-128">La anidación de los dos ámbitos en un ámbito de larga ejecución y la invocación de la forma Compensar (dirigida a la transacción de larga ejecución) desde el controlador de excepción para el ámbito de larga ejecución producirá el mismo comportamiento descrito más arriba.</span><span class="sxs-lookup"><span data-stu-id="25016-128">Nesting the two scopes in a long running scope and invoking the Compensate shape (targeting the long running transaction) from the exception handler for the long running scope will result in the same behavior as described above.</span></span> <span data-ttu-id="25016-129">La orquestación completa no se podría marcar como atómica puesto que las transacciones atómicas no permiten transacciones anidadas.</span><span class="sxs-lookup"><span data-stu-id="25016-129">The whole orchestration could not be marked atomic as atomic transactions do not allow nested transactions.</span></span>  
  
 <span data-ttu-id="25016-130">**Adaptadores de transacción con transacciones atómicas**</span><span class="sxs-lookup"><span data-stu-id="25016-130">**Transacted adapters with atomic transactions**</span></span>  
  
 <span data-ttu-id="25016-131">![Adaptadores con transacciones atómicas con transacciones](../core/media/bts-trans-orch-fig6.gif "BTS_Trans_Orch_Fig6")</span><span class="sxs-lookup"><span data-stu-id="25016-131">![Transacted adapters with atomic transactions](../core/media/bts-trans-orch-fig6.gif "BTS_Trans_Orch_Fig6")</span></span>